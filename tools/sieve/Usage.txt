memSieve:
========

memSieve or Sieve is a utility which makes suggestions for fast malloc candidates. Fast malloc refers to the allocations to the tier-one main memory. memSieve consists of a malloc library, an SST component, and a few post-processing utilities. The backtracing malloc library (btmalloc), implemented in btmalloc.cpp, traces the callsites of all allocations. The traces can be made smaller by a user specified cutoff size for the allocations. The Sieve component of SST simulataneously traces all the access to the main memory. The accesses are then accumulated at a page level granularity by the SST addrHistogrammer module and reported in the statistics. The accumulateAccesses.py script reads the statistics output, sorts the pages in the decreasing order of hotness, and lists them in hotPages.txt. The printTraces.cpp utility pieces together the malloc traces (backTrace.txt) generated by btmalloc.cpp, and hot pages information (hotPages.txt), to make suggestions for the memory allocation calls to be placed in the tier-one main memory. It currently makes suggestions for just one tier of memory, but can be easily modified to support any number of levels. The size for the first tier memory is specified in a config file supplied as a argument.

Supported Platforms:
-------------------
memSieve has been tested on the following platforms:
OS: Linux
Compilers: GCC (v4.8), Intel (v15)
Note: The default OpenMP with Intel 15 does not work with btmalloc library. btmalloc uses the libc's backtrace functionality which currently does not work correctly with the default Intel's (v15) OpenMP runtime. The OMP runtime appears to set one of the return addresses to a NULL ptr causing a segmentation fault when backtrace is invoked. The solution is to download Intel's OpenMP runtime source, compile with "mode=debug", and add the library to the dynamic link path (ie LD_LIBRARY_PATH) for the SST run using envparam attributes (in the SST config file) for the executable. Please refer to the sample sst config file in this directory for setting the environment variables of an executable.

Workflow:
--------
(i) Install SST
(ii) If using Intel 15 compiler (and OpenMP in the application), download Intel's OpenMP runtime source and compile with "mode=debug." Refer to the note in the Supported Platforms section.
(iii) Insert ariel_enable() in the application to manipulate the start point for the simulation. It helps to avoid profiling the often non-crucial setup phase of an application.
(iv) Compile the application to be profiled with -g, and link against libarielapi.so.
(iii) Build ariel and sieve tools from the source under the <sst simulator source>/tools folder
(iv)  Go to an experiments folder, and copy the sample sst config file
(v)   Modify the sample sst config file you find in this directory to:
      (a) specify the application binary, including path, and parameters
      (b) path to ariel frontend
      (c) path to sieve's btmalloc library. The mallocs in the application are bound to btmalloc through LD_PRELOAD's weak symbol linking mechanism.
      (d) the range of virtual addresses to be profiled by the statistics package
      (e) any other options such as number of cores, connectivity, cache sizes, and clock speeds.

(vi)   Set the environment variable BTMALLOC_CUTOFF_SIZE (in bytes) to prune the malloc trace. Any allocation below this cutoff will not be tracked. The default cutoff is 8 B.
(vii)  Run the sst configuration file eg: shell-prompt$ sst <name of the config file>. It will generate Statistics.csv file.
(viii) Run accummulateAccesses.py in this folder. This python script can be modified to look for Statistics.csv file in a different folder.
       python <path to accumulateAccesses.py>
     It must generate hotPages.txt file.
(ix)  Copy the sample config file for printTraces from tools/sieve. Modify if necessary. The config file supports the following parameters:
      (a) Path to the application binary. No quotes necessary anywhere in this file.
      (b) Path to the back trace file. It doesn't have to be called backTrace.txt.
      (c) Path to the hot pages file. Again, it doesn't have to be called hotPages.txt.
      (d) Size of the first-level main memory
(x) Now run the printTrace tool under tools/sieve. It takes the name of the config file as an argument.

     <tools/sieve>/printTrace -c <config file name> 2&> suggestions.txt

    Redirect the output to a text file for convenience.

Interpreting the suggestions:
----------------------------
printTrace reports the suggestions (callsites for allocations) in decreasing order of importance as determined by the hotness during profiling. By default, it reports a call site only once along with a list of trip numbers for this call site. The trip numbers represents which accesses of this call site were hot. For example, a mesh for some scientific computation typically has many elements. The storage for all these elements are typically created from the same call site. However, let us assume that only a few of these elements are hot. If sieve reports just the callsite then there is no way to know which elements (allocations) were hot. By reporting the trip numbers, we can relate the information back to the source to identify the hot elements (allocations). eg: if there were 10 elements, and this call site was accessed only 10 times, then a trip number of 7 reported means that the 7 elemental type in this mesh is hot, and a candidate for fast memory. In a sense, the trip numbers represent hot timestamps of this call site but which hopefully can be more easily interpreted. The trip numbers are either singletons, or right open intervals for ranges. They are sorted in the decreasing order of hotness within a call site. The user can choose to see an inorder listing of the callsites. In this mode, the callsites will be repeated, and most likely intermixed with other callsites. Setting SUGGESTION_INORDER for the environment variable SIEVE_SUGGESTION_STYLE will turn on this mode. However, it is not recommended as you will be swamped with voluminous output.

OSX and Clang:
-------------
memSieve, and in particular backTrace malloc, has not been tested with Clang because Clang currently does not support OpenMP. However to work with OSX (Clang / GCC compilers), try using DYLD_INSERT_LIBRARIES and DYLD_FORCE_FLAT_NAMESPACE options to achieve weak symbol linking.
